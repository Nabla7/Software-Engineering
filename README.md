# Software-Engineering

Collection of factoids and such things from our software engineering course at University of Antwerp

---

## Week 1: Introduction

### Summary (i)

#### 1. How does Software Engineering differ from programming?

   > Software Engineering encompasses the systematic design, development, and maintenance of software applications, considering aspects like requirements, design, testing, and maintenance. Programming, on the other hand, is merely the act of writing code.

#### 2. Why is programming only a small part of the cost of a “real” software project?

   > Beyond programming, a software project incurs costs in requirements gathering, design, testing, documentation, deployment, maintenance, training, and more. These activities often consume more time and resources than just writing the code.

#### 3. Give a definition for “traceability”.
   
   > Traceability refers to the ability to relate software artifacts to one another and to their source requirements, ensuring that all requirements are met and changes can be tracked throughout the software lifecycle.

#### 4. What is the difference between analysis and design?

   > Analysis focuses on understanding the problem, gathering requirements, and specifying what the system should do. Design, on the other hand, focuses on how the system will fulfill those requirements, determining the architecture, components, and their relationships.

#### 5. Explain verification and validation in simple terms.

   > Verification answers the question, "Are we building the product right?" It ensures the product meets its specifications. Validation answers, "Are we building the right product?" It ensures the product meets the user's needs.

#### 6. Why is the “waterfall” model unrealistic? Why is it still used?

   > The waterfall model assumes that each phase (like requirements, design, implementation) is completed before the next begins, which is often unrealistic as requirements can change or issues can be discovered later. However, it's still used because of its simplicity and clear structure.

#### 7. Can you explain the difference between iterative development and incremental development?

   > Iterative development involves refining the system through repeated cycles, enhancing its functionality with each iteration. Incremental development delivers the system in parts or "increments", adding new features with each increment.

### Summary (ii)

#### 1. What is your preferred definition of Software Engineering? Why?
   
   > Software Engineering is the disciplined application of engineering principles to design, develop, and maintain software systems. This definition encapsulates both the technical and process-oriented nature of the field.

#### 2. Why do we choose “Correctness” & “Traceability” as evaluation criteria? Can you imagine some others?

   > Correctness ensures the software behaves as expected, while traceability ensures changes and requirements can be tracked. Other criteria could be maintainability, efficiency, reliability, and usability.

#### 3. Why is “Maintenance” a strange word for what is done during the activity?

   > Because it often involves not just fixing bugs or updating software but also adding new features, adapting to new platforms, or improving performance.

#### 4. Why is risk analysis necessary during incremental development?

   > Incremental development introduces changes with each increment, and risk analysis ensures that these changes don't introduce unforeseen problems or jeopardize the project's success.

#### 5. How can you validate that an analysis model captures users’ real needs?

   > By involving users in the validation process, such as through reviews, walkthroughs, or prototyping, and gathering their feedback.

#### 6. When does analysis stop and design start?

   > Analysis stops once the problem is fully understood and requirements are specified. Design starts when you begin determining how to fulfill those requirements.

#### 7. When can implementation start?

   > Implementation can start after the design phase is completed and there's a clear plan for how the system will be built.

#### 8. Can you compare the Unified Process and the Spiral Model?

   > Both are iterative models, but the Unified Process is more structured with specific phases (Inception, Elaboration, Construction, Transition) and emphasizes use-case driven development. The Spiral Model focuses more on risk-driven development with repeated cycles of planning, risk analysis, engineering, and evaluation.

#### 9. Can you explain the values behind the Agile Manifesto?

   > The Agile Manifesto values:
   > - Individuals and interactions over processes and tools
   > - Working software over comprehensive documentation
   > - Customer collaboration over contract negotiation
   > - Responding to change over following a plan

#### 10. Can you identify some synergies between the techniques used during extreme programming?

   > Pair programming, continuous integration, and test-driven development synergize by promoting code quality, early defect detection, and team collaboration.


#### 11. Can you explain how the different steps in the scrum process create a positive feedback loop?
    
   > Sprints end with reviews and retrospectives, allowing the team to show progress, gather feedback, and continuously improve, creating a loop of planning, action, feedback, and adjustment.

#### 12. How does scrum reduce risk?
    
   > Scrum's iterative approach, with frequent feedback and regular adjustments, ensures that deviations from the desired outcome are caught and corrected early.

#### 13. Is it possible to apply Agile Principles with the Unified Process?
    
   > Yes, the Unified Process can be tailored to be more agile by emphasizing early and continuous delivery, close customer collaboration, and flexibility to change.

#### 14. Did the UML succeed in becoming the Universal Modeling Language? Motivate your answer.
    
   > UML has become widely accepted as a standard for modeling software systems, especially in object-oriented design. However, while it's a powerful tool, not every project or organization uses it, and some find it overly complex for certain tasks. So, while it's "universal" in the sense of being a standard, it's not universally used in every context.
